#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <inttypes.h>
#include <jni.h>
#include <jni_sw_extend.h> // generated by javah via maven-native-plugin
#include <assert.h>
#include <stdlib.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/time.h>
#include <time.h>
#include <inttypes.h>

#define NOT_READY 0
#define DONE 1
#define FLAG_NUM 2


void print_current_time_with_ns (void)
{
  long            ns; // Milliseconds
  time_t          s;  // Seconds
  struct timespec spec;

  clock_gettime(CLOCK_REALTIME, &spec);

  s  = spec.tv_sec;
  ns = spec.tv_nsec; // Convert nanoseconds to milliseconds

  printf("Current time: %"PRIdMAX".%09ld seconds since the Epoch\n",
           (intmax_t)s, ns);
}


int send_int_array(int* int_buf, int buf_size) {
  // For profiling only
  //struct timeval  tv;
  //gettimeofday(&tv, NULL);
  //double time_in_mill = (tv.tv_sec) * 1000 + (tv.tv_usec) / 1000 ; // convert tv_sec & tv_usec to millisecond
  //printf("Send time (ms): %lf\n", time_in_mill);
  print_current_time_with_ns();

  // sockets
  struct sockaddr_in stSockAddr;
  int Res;

  // socket setup
  int SocketFD = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); 
  if (-1 == SocketFD) {
    perror("cannot create socket");
    exit(EXIT_FAILURE);
  }

  memset(&stSockAddr, 0, sizeof(stSockAddr));
  stSockAddr.sin_family = AF_INET;
  stSockAddr.sin_port = htons(7000);
  Res = inet_pton(AF_INET, "127.0.0.1", &stSockAddr.sin_addr);

  if (0 > Res) {
    perror("error: first parameter is not a valid address family");
    close(SocketFD);
    exit(EXIT_FAILURE);
  }
  else if (0 == Res) {
    perror("char string (second parameter does not contain valid ipaddress)");
    close(SocketFD);
    exit(EXIT_FAILURE);
  }

  int connect_ret = connect(SocketFD, (struct sockaddr *)&stSockAddr, sizeof(stSockAddr));
  if (connect_ret == -1) {
    perror("connect failed");
    close(SocketFD);
    //exit(EXIT_FAILURE);
    return 1;
  }
  else {
    //printf("Shmid: %d, Data size: %d, sent\n", int_buf[0], int_buf[1]);
    send(SocketFD, int_buf, buf_size * sizeof(int), 0);
    (void) shutdown(SocketFD, SHUT_RDWR);
    close(SocketFD);
    return 0;
  }

}


JNIEXPORT jshortArray JNICALL Java_cs_ucla_edu_bwaspark_jni_SWExtendFPGAJNI_swExtendFPGAJNI
(JNIEnv *env, jobject thisObj, jint retTaskNum, jbyteArray arrayIn)
{
  // shared memory
  int shmid;
  char *shm_addr = NULL;

  // polling setting
  struct timespec deadline;
  deadline.tv_sec = 0;
  deadline.tv_nsec = 100;

  printf("Get JNI data\n");
  jbyte* dataArray = (jbyte*) (*env)->GetByteArrayElements(env, arrayIn, NULL);
  jsize dataArraySize = (*env)->GetArrayLength(env, arrayIn);

  // shared memory setup
  if((shmid = shmget(IPC_PRIVATE, FLAG_NUM * sizeof(int) + dataArraySize * sizeof(jbyte), IPC_CREAT | 0666)) < 0) {
    perror("shmget failed.");
    exit(1);
  }
  else
    printf("Create shared memory: %d\n", shmid);

  if((shm_addr = (char*) shmat(shmid, NULL, 0)) == (char *) -1) {
    perror("Client: shmat failed.");
    exit(1);
  }
  else
    printf("Client: attach shared memory: %p\n", shm_addr);

  // initialize the flags of shared memory
  *((int*)shm_addr) = NOT_READY;
  *((int*)(shm_addr + sizeof(int))) = NOT_READY;
  
  // put input data
  printf("Client: put input data\n");
  //printf("Shmid: %d, Dataarray size: %d\n", shmid, dataArraySize);
  memcpy(shm_addr + FLAG_NUM * sizeof(int), dataArray, (int) dataArraySize * sizeof(jbyte));
  *((int*)shm_addr) = DONE;
  //printf("After memcpy\n", shmid, dataArraySize);

  // send a request (shmid) and data array size to the FPGA host thread
  int int_buf[2];
  int_buf[0] = shmid;
  int_buf[1] = dataArraySize / 4;
  //printf("Shmid: %d, Data size (# of int): %d, Task Num: %d\n", int_buf[0], int_buf[1], retTaskNum);
  printf("Send shmid and data size through socket\n");
  while(send_int_array(int_buf, 2)) clock_nanosleep(CLOCK_REALTIME, 0, &deadline, NULL);

  // poll the shared memory
  printf("Poll\n");
  volatile int done = 0;
  while(done == 0) {
    done = (int) *((int*)(shm_addr + sizeof(int)));
    clock_nanosleep(CLOCK_REALTIME, 0, &deadline, NULL);
    //usleep(1);
  }

  //printf("fill data\n");
  jshortArray ret = (*env)->NewShortArray(env, retTaskNum);
  // copy data from the shared memory
  int i;
  jshort* fill = (jshort*) malloc(retTaskNum * sizeof(jshort));
  for(i = 0; i < retTaskNum; i++)
    fill[i] = *((jshort*)(shm_addr + (FLAG_NUM * 2 + i) * sizeof(jshort)));

  // free the shared memory
  shmdt(shm_addr);
  shmctl(shmid, IPC_RMID, 0);

  (*env)->SetShortArrayRegion(env, ret, 0, retTaskNum, fill);
  (*env)->ReleaseByteArrayElements(env, arrayIn, dataArray, 0); 
  free(fill);

  printf("done\n");
  return ret;
}
